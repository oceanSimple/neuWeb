# 项目搭建

## 父项目的搭建

### 1. 注意事项

> - 推荐：父项目控制子项目的依赖版本
>- 推荐：尤其是spring-boot和spring-cloud的版本以及spring-cloud-alibaba的版本
>- 注意：jdk的版本，spring-boot3.0以上需要jdk11
>- 注意：其他的依赖不代表最终版本，后续功能的需要请自行添加

### 2. maven配置

    ```
    <?xml version="1.0" encoding="UTF-8"?>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>
    
        <groupId>com.ocean</groupId>
        <artifactId>backend</artifactId>
        <version>1.0-SNAPSHOT</version>
    
        <!--依赖版本的统一管理-->
        <properties>
            <maven.compiler.source>18</maven.compiler.source>
            <maven.compiler.target>18</maven.compiler.target>
            <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
            <!--版本管理-->
            <spring-cloud.version>2022.0.0</spring-cloud.version>
            <spring-boot.version>3.0.2</spring-boot.version>
            <spring-cloud-alibaba.version>2022.0.0.0-RC2</spring-cloud-alibaba.version>
            <mybatis-plus.version>3.5.3.1</mybatis-plus.version>
            <mysql-connector-j.version>8.0.33</mysql-connector-j.version>
            <druid.version>1.2.18</druid.version>
            <fastjson2.version>2.0.38</fastjson2.version>
        </properties>
    
        <!--默认依赖导入-->
        <dependencyManagement>
            <dependencies>
                <!--spring-cloud依赖-->
                <dependency>
                    <groupId>org.springframework.cloud</groupId>
                    <artifactId>spring-cloud-dependencies</artifactId>
                    <version>${spring-cloud.version}</version>
                    <type>pom</type>
                    <scope>import</scope>
                </dependency>
                <!--spring-boot一依赖-->
                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-dependencies</artifactId>
                    <version>${spring-boot.version}</version>
                    <type>pom</type>
                    <scope>import</scope>
                </dependency>
                <!--spring-cloud-alibaba-->
                <dependency>
                    <groupId>com.alibaba.cloud</groupId>
                    <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                    <version>${spring-cloud-alibaba.version}</version>
                    <type>pom</type>
                    <scope>import</scope>
                </dependency>
                <!--mybatis-plus依赖-->
                <dependency>
                    <groupId>com.baomidou</groupId>
                    <artifactId>mybatis-plus-boot-starter</artifactId>
                    <version>${mybatis-plus.version}</version>
                </dependency>
                <!--mysql-connector-j依赖-->
                <dependency>
                    <groupId>com.mysql</groupId>
                    <artifactId>mysql-connector-j</artifactId>
                    <version>${mysql-connector-j.version}</version>
                </dependency>
                <!--druid依赖-->
                <dependency>
                    <groupId>com.alibaba</groupId>
                    <artifactId>druid</artifactId>
                    <version>${druid.version}</version>
                </dependency>
                <!--fastjson2依赖-->
                <dependency>
                    <groupId>com.alibaba.fastjson2</groupId>
                    <artifactId>fastjson2</artifactId>
                    <version>${fastjson2.version}</version>
                </dependency>
            </dependencies>
        </dependencyManagement>
    
        <!--公共依赖管理-->
        <dependencies>
            <!--lombok依赖-->
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
            </dependency>
            <!--bootstrap依赖-->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-starter-bootstrap</artifactId>
            </dependency>
        </dependencies>
    </project>
    ```

## common-package

### 1. maven配置

> 需要的lombok依赖在父项目中已经导入

   ```
   <?xml version="1.0" encoding="UTF-8"?>
   <project xmlns="http://maven.apache.org/POM/4.0.0"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
       <modelVersion>4.0.0</modelVersion>
       <parent>
           <groupId>com.ocean</groupId>
           <artifactId>backend</artifactId>
           <version>1.0-SNAPSHOT</version>
       </parent>
   
       <artifactId>common-package</artifactId>
   
       <properties>
           <maven.compiler.source>18</maven.compiler.source>
           <maven.compiler.target>18</maven.compiler.target>
           <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
       </properties>
   
       <dependencies>
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-aop</artifactId>
               <version>3.1.0</version>
           </dependency>
   
           <dependency>
               <groupId>com.alibaba.fastjson2</groupId>
               <artifactId>fastjson2</artifactId>
           </dependency>
       </dependencies>
   </project>
   ```

### 2. 前后端公共返回类

   ```java
   package com.ocean.comomPackage.common;

import lombok.Data;

/**
 * 通用返回结果类
 *
 * @param <T>
 */
@Data
public class R<T> {

    private Integer code; //编码：1成功，0和其它数字为失败

    private String msg; //错误信息

    private T data; //数据

    public static <T> R<T> success(Integer code, String msg, T object) {
        R<T> r = new R<T>();
        r.data = object;
        r.code = code;
        r.msg = msg;
        return r;
    }

    public static <T> R<T> error(Integer code, String msg) {
        R r = new R();
        r.msg = msg;
        r.code = 0;
        return r;
    }
}
   ```

### 3. RCodeEnum

> 用来规范返回的code（后续可以添加更多枚举）

   ```java
   package com.ocean.commonPackage.common.RCode;

public enum RCodeEnum {
    SUCCESS(200, "成功"), // 成功
    PARAM_ERROR(400, "参数错误"), // 参数错误
    NO_DATA(404, "没找到数据"), // 没找到数据
    IS_DELETED(405, "数据已被删除"), // 数据已被删除
    ERROR(500, "错误"), // 错误
    IDENTIFY_ERROR(501, "身份验证失败"), // 身份验证失败
    ;

    private Integer code;
    private String msg;

    RCodeEnum(Integer code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    public Integer getCode() {
        return this.code;
    }

    public String getMsg() {
        return this.msg;
    }
}
   ```

### 4. 日志aop

1. 导入aop依赖
2. 自定义注解
   ```java
   package com.ocean.commonPackage.anotation;
   
   import java.lang.annotation.ElementType;
   import java.lang.annotation.Retention;
   import java.lang.annotation.RetentionPolicy;
   import java.lang.annotation.Target;
   
   @Target(ElementType.METHOD)
   @Retention(RetentionPolicy.RUNTIME)
   public @interface ErrorLog {
       String value() default "";
   }
   ```
3. aop处理
   ```java
   package com.ocean.commonPackage.aop;
   
   import com.ocean.commonPackage.anotation.ErrorLog;
   import lombok.extern.slf4j.Slf4j;
   import org.aspectj.lang.ProceedingJoinPoint;
   import org.aspectj.lang.annotation.Around;
   import org.aspectj.lang.annotation.Aspect;
   import org.aspectj.lang.annotation.Pointcut;
   import org.springframework.stereotype.Component;
   
   import java.lang.reflect.Method;
   import java.util.Arrays;
   
   @Component
   @Slf4j
   @Aspect
   public class ErrorLogAspect {
       @Pointcut("@annotation(com.ocean.commonPackage.anotation.ErrorLog)")
       public void errorLogPointCut() {
       }
   
       @Around("errorLogPointCut()")
       public Object errorLogAround(ProceedingJoinPoint point) throws ClassNotFoundException {
           Object result = null;
           try {
               // 执行方法，捕获异常
               result = point.proceed();
           } catch (Throwable throwable) {
               // 获取类路径
               String classPath = point.getThis().toString().split("@")[0];
               // 通过反射获取类
               Class<?> aClass = Class.forName(classPath);
               // 获取方法（注意，此方法要求方法名唯一！）
               for (Method method : aClass.getMethods()) {
                   if (method.getName().equals(point.getSignature().getName())) {
                       ErrorLog annotation = method.getAnnotation(ErrorLog.class);
                       log.error("出错方法功能: {}", annotation.value());
                   }
               }
               log.error("错误的方法：{}", point.getSignature());
               log.error("传入的参数: {}", Arrays.toString(point.getArgs()));
               log.error("错误原因: {}", throwable.getMessage());
               log.error("错误堆栈: {}", (Object[]) throwable.getStackTrace());
               log.error("错误类: {}", throwable.getClass());
           }
           return result;
       }
   }
   ```
4. 使用
   > 直接在controller中的方法上添加自定义注解即可

### 5. 校验前端传递的参数

> 提要：本功能用来检查controller层方法接收的参数的合法性。本项目强制规定，参数有且仅有一个。可以是一个String的参数或者一个封装的实体类。

1. 自定义注解
    - CheckParam
      > 此注解用于controller的方法上，通知spring的aop要检查此方法的参数
       ```java
       package com.ocean.commonPackage.anotation;
       
       import java.lang.annotation.ElementType;
       import java.lang.annotation.Retention;
       import java.lang.annotation.RetentionPolicy;
       import java.lang.annotation.Target;
       
       @Target(ElementType.METHOD)
       @Retention(RetentionPolicy.RUNTIME)
       public @interface CheckParam {
       }
       ```
    - ParamRename
      > 1. 放在实体类的属性上，用来方便自定义的校验方式
      > 2. value：用来指定前端传递的参数名，与后端预定义的参数名类型匹配，如果不指定，则默认为参数名
      > 3. regex：用来指定正则表达式，用来校验参数是否符合要求，如果不指定，则通过参数名或value寻找预定义的regex
      > 4. errorMessage：用来指定错误信息，如果不指定，则通过参数名或value寻找预定义的errorMessage
       ```java
       package com.ocean.commonPackage.anotation;
       
       import java.lang.annotation.ElementType;
       import java.lang.annotation.Retention;
       import java.lang.annotation.RetentionPolicy;
       import java.lang.annotation.Target;
       
       @Retention(RetentionPolicy.RUNTIME)
       @Target(ElementType.FIELD)
       public @interface ParamRename {
           String value() default "";
       
           String regex() default "";
       
           String errorMessage() default "";
       }
       ```
2. 工具实体类
    1. SingleParam
       > 1. 用于封装检查的实体类
       > 2. 包含参数名、参数值、参数的正则表达式
       ```java
       package com.ocean.commonPackage.util.frontParam;
    
       import lombok.AllArgsConstructor;
       import lombok.Data;
       import lombok.NoArgsConstructor;
    
       @AllArgsConstructor
       @Data
       @NoArgsConstructor
       public class SingleParam {
           private String name; // 参数名
           private String data; // 参数值
           private Pattern pattern; // 参数的正则表达式
    
           public SingleParam(String name, String data) {
               this.name = name;
               this.data = data;
               this.pattern = new Pattern("", "");
           }
       }
       ```
    2. Pattern
       ```java
       package com.ocean.commonPackage.util.frontParam;
    
       import lombok.AllArgsConstructor;
       import lombok.Data;
       import lombok.NoArgsConstructor;
    
       @AllArgsConstructor
       @Data
       @NoArgsConstructor
       public class Pattern {
           private String regex; // 正则表达式
           private String message; // 错误信息
       }
       ```
    3. staticPatternMap
       > 1. 用来保存预定义的正则表达式和错误信息
       > 2. map的key是预定义的属性名，如果传入的参数名称与key不一样，但校验规则一样，使用@ParamRename注解指定value即可
       ```java
       package com.ocean.commonPackage.util.frontParam;
    
       import java.util.HashMap;
    
       public class StaticPatternMap {
           private static HashMap<String, Pattern> patternMap = new HashMap<>();
    
           public static HashMap<String, Pattern> getPatternMap() {
               initMap();
               return patternMap;
           }
    
           private static void initMap() {
               patternMap
                       .put("code", new Pattern("^[0-9]{8}$", "账号必须是8位数字"));
               patternMap
                       .put("nickname", new Pattern("^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$", "账号必须是8位数字"));
               patternMap
                       .put("email", new Pattern("^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$", "邮箱格式不正确"));
               patternMap
                       .put("password", new Pattern("^[a-zA-Z0-9]{6,16}$", "密码必须是6-16位字母或数字"));
               patternMap
                       .put("emailVerifyCode", new Pattern("^[0-9]{4}$", "邮箱验证码必须是4位数字"));
           }
       }
       ```
3. 参数检查类
    - 总体介绍
      > 1. 本函数设置了三个方法
      > 2. public static <T> R<Boolean> checkFrontParam(T param)：这是提供给aop使用的接口，接收aop函数传入的方法参数，开启检查
      > 3. private static R<Boolean> checkSingleParam(Object param)： 这是真正用来检查参数的方法，对传入的SingleParam类进行检查
      > 4. private static <T> R<Boolean> checkObjParam(T obj)
           ：这个是用来检查类的属性，此类通过反射获取实体类所有的属性，并逐个封装成SingleParam，调用checkSingleParam(Object
           param)方法进行检查
    - checkFrontParam(T param)
       ```
        public static <T> R<Boolean> checkFrontParam(T param) {
            if (param instanceof SingleParam) { // 如果参数只有一个string类型的参数，那么就直接检查
                return checkSingleParam(param);
            } else { // 如果参数是一个对象，那么就通过反射检查
                return checkObjParam(param);
            }
        }
       ```
    - checkSingleParam(Object param)
       ```
       private static R<Boolean> checkSingleParam(Object param) {
            SingleParam singleParam = (SingleParam) param;
            // 检查参数名和参数值是否为空
            if (singleParam.getName() == null || singleParam.getData() == null) {
                return R.error(RCodeEnum.PARAM_ERROR.getCode(), "参数名或参数值不能为空");
            }
    
            // 判断参数是否自带正则表达式检查
            if (!singleParam.getPattern().getRegex().equals("")) { // 如果存在正则表达式，进行检查
                boolean flag = singleParam.getData().matches(singleParam.getPattern().getRegex());
                if (!flag)
                    return R.error(RCodeEnum.ERROR.getCode(), singleParam.getPattern().getMessage());
            } else { // 如果没自带正则表达式，检查是否存在默认正则表达式
                Pattern pattern = patternMap.get(singleParam.getName());
                if (pattern != null) { // 如果找到pattern，进行检查
                    boolean flag = singleParam.getData().matches(pattern.getRegex());
                    if (!flag)
                        return R.error(RCodeEnum.ERROR.getCode(), pattern.getMessage());
                }
            }
            // 如果不存在pattern，说明不需要检查，直接返回成功
            return R.success(RCodeEnum.SUCCESS.getCode(), "参数检查通过", true);
        }
       ```
    - checkObjParam(T obj)
       ```
       private static <T> R<Boolean> checkObjParam(T obj) {
            // 通过反射获取所有的属性和属性值，并一次进行检查
            Class<?> aClass = obj.getClass();
            // 获取参数类的所有属性
            Field[] fields = aClass.getDeclaredFields();
            for (Field field : fields) { // 循环：对每一个属性进行参数校验
                try {
                    field.setAccessible(true); // 启动对private属性的调用
                    R<Boolean> flag; // 用于接收检查结果
                    SingleParam singleParam; // 用于存储参数名、参数值、正则表达式
                    // 获取属性值，判断属性是否带有ParamRename注解
                    if (field.isAnnotationPresent(ParamRename.class)) {
                        ParamRename paramAnnotation = field.getAnnotation(ParamRename.class);
                        String paramName
                                = paramAnnotation.value().equals("") ? field.getName() : paramAnnotation.value();
                        singleParam = new SingleParam(paramName, field.get(obj).toString(), new Pattern(paramAnnotation.regex(), paramAnnotation.errorMessage()));
                    } else {
                        singleParam = new SingleParam(field.getName(), field.get(obj).toString());
                    }
    
                    flag = checkSingleParam(singleParam);
                    if (!RCodeEnum.SUCCESS.getCode().equals(flag.getCode())) { // 如果检查失败，直接返回
                        return flag;
                    }
                } catch (IllegalAccessException e) {
                    throw new RuntimeException(e);
                }
            }
            return R.success(RCodeEnum.SUCCESS.getCode(), "参数检查通过", true);
        }
       ```
4. aop类
   ```java
   package com.ocean.commonPackage.aop;
   
   import com.ocean.commonPackage.common.R;
   import com.ocean.commonPackage.common.RCode.RCodeEnum;
   import com.ocean.commonPackage.util.frontParam.CheckFrontParam;
   import com.ocean.commonPackage.util.frontParam.SingleParam;
   import lombok.extern.slf4j.Slf4j;
   import org.aspectj.lang.ProceedingJoinPoint;
   import org.aspectj.lang.annotation.Around;
   import org.aspectj.lang.annotation.Aspect;
   import org.aspectj.lang.annotation.Pointcut;
   import org.aspectj.lang.reflect.CodeSignature;
   import org.springframework.stereotype.Component;
   
   @Component
   @Slf4j
   @Aspect
   public class CheckParamAspect {
       @Pointcut("@annotation(com.ocean.commonPackage.anotation.CheckParam)")
       public void checkParamPointCut() {
       }
   
       @Around("checkParamPointCut()")
       public Object errorLogAround(ProceedingJoinPoint point) throws Throwable {
           // 检查参数的数量与格式
           // 本项目默认controller层的参数只有一个（为每一种前端的提交单独设计了提交实体类）
           if (point.getArgs().length == 0) { // 无参，返回错误信息
               return R.error(RCodeEnum.ERROR.getCode(), "参数检查aop：参数不能为空");
           } else if (point.getArgs().length > 1) { // 多参，返回错误信息
               return R.error(RCodeEnum.ERROR.getCode(), "参数检查aop：参数数量过多（大于1）");
           } else { // 单参，检查参数格式
               Object param = point.getArgs()[0]; // 获取参数
               R<Boolean> flag; // 检查结果
               // 参数有两种格式，一种是单个参数（string），一种是实体类
               if (param instanceof String) { // 单个参数，类型一定为string（项目规定）
                   // 获取参数名
                   String parameterName = ((CodeSignature) point.getSignature()).getParameterNames()[0];
                   flag = CheckFrontParam.checkFrontParam(new SingleParam(parameterName, (String) param));
               } else {
                   flag = CheckFrontParam.checkFrontParam(param);
               }
               if (!RCodeEnum.SUCCESS.getCode().equals(flag.getCode())) {
                   // 如果参数检查失败，直接返回错误信息
                   return flag;
               } else {
                   // 如果所有参数检查成功，放行
                   return point.proceed(point.getArgs());
               }
           }
       }
   }
   ```

### 6. 主要功能

> 用于保存公共实体类，例如：用户实体类，前后端传递参数的实体类等等

## mybatis-plus-package

> 主要用于保存对应表的实体类，以及异常处理、全局配置、自动注入等等

### 1. 依赖项

   ```
   <!--mybatis-plus依赖-->
   <dependency>
      <groupId>com.baomidou</groupId>
      <artifactId>mybatis-plus-boot-starter</artifactId>
   </dependency>
   <!--mysql依赖-->
   <dependency>
      <groupId>com.mysql</groupId>
      <artifactId>mysql-connector-j</artifactId>
   </dependency>
   <!--druid依赖-->
   <dependency>
      <groupId>com.alibaba</groupId>
      <artifactId>druid</artifactId>
   </dependency>
   <!--web依赖，主要用于处理全局异常的annotation-->
   <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
   </dependency>
   <!--common-package-->
   <dependency>
      <groupId>com.ocean</groupId>
      <artifactId>common-package</artifactId>
      <version>1.0-SNAPSHOT</version>
   </dependency>
   ```

### 2. 实体类举例

   ```java
   package com.ocean.mpPackage.sqlEntity;

import com.baomidou.mybatisplus.annotation.FieldFill;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigInteger;
import java.sql.Timestamp;

@Data
@AllArgsConstructor
@NoArgsConstructor
@TableName("user")
public class User {
    private BigInteger id;  // 数据库随机uuid
    private String code;    // 学号，规定为8位
    private String password; // 密码
    private String nickname; // 昵称
    private String campus; // 校区
    private String dormitory; // 宿舍
    private Integer isDeleted; // 数据库插入时会默认为0，删除时会改为1
    private String email; // 邮箱
    private String phone; // 手机号
    @TableField(fill = FieldFill.INSERT)
    private Timestamp gmtCreate; // 数据库插入时会自动填充
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Timestamp gmtModified; // 数据库插入和更新时会自动填充
    @TableField(exist = false)
    private String token; // 排除字段，不与数据库进行匹配，只是用来判断登录的权限
}
   ```

### 3. 自动填充配置（时间）

   ```java
   package com.ocean.mpPackage.handler;

import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import org.apache.ibatis.reflection.MetaObject;
import org.springframework.stereotype.Component;

import java.sql.Timestamp;
import java.time.LocalDateTime;

@Component
public class MyMetaObjectHandler implements MetaObjectHandler {
    @Override
    public void insertFill(MetaObject metaObject) {
        metaObject.setValue("gmtCreate", Timestamp.valueOf(LocalDateTime.now()));
        metaObject.setValue("gmtModified", Timestamp.valueOf(LocalDateTime.now()));
    }

    @Override
    public void updateFill(MetaObject metaObject) {
        // 注意，如果要这里生效，需要这样使用update：update(new User(), updateWrapper);
        // 如果update(updateWrapper);使用，更改不会生效！！！
        // 下面三种方式均可以触发更新
        // boolean saveOrUpdate(T entity)
        // boolean saveOrUpdate(T entity, Wrapper<T> updateWrapper)
        // update(T entity, Wrapper<T> updateWrapper)
        metaObject.setValue("gmtModified", Timestamp.valueOf(LocalDateTime.now()));
    }
}
   ```

### 4. 处理异常

   ```java
   package com.ocean.mpPackage.globalException;

import com.ocean.commonPackage.common.R;
import com.ocean.commonPackage.common.RCode.RCodeEnum;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

import java.sql.SQLIntegrityConstraintViolationException;
import java.sql.SQLSyntaxErrorException;

@ControllerAdvice
@ResponseBody
public class SqlExceptionHandler {
    // 处理重复异常
    @ExceptionHandler(value = SQLIntegrityConstraintViolationException.class)
    public R<String> exceptionHandler(SQLIntegrityConstraintViolationException ex) {
        // 处理重复异常
        // Duplicate entry 'ocean' for key 'idx_username'
        if (ex.getMessage().contains("Duplicate entry")) {
            String[] split = ex.getMessage().split(" ");
            String msg = split[2] + "已存在";
            return R.error(RCodeEnum.ERROR.getCode(), msg);
        }
        return R.error(RCodeEnum.ERROR.getCode(), "未知错误：" + ex.getMessage());
    }

    // 处理列、表、数据库不存在异常
    @ExceptionHandler(value = SQLSyntaxErrorException.class)
    public R<String> exceptionHandler(SQLSyntaxErrorException ex) {
        // 处理列名不存在异常
        // Unknown column 'username' in 'field list'
        if (ex.getMessage().contains("Unknown column")) {
            String[] split = ex.getMessage().split(" ");
            String msg = "列：" + split[2] + ",不存在";
            return R.error(RCodeEnum.ERROR.getCode(), msg);
        } else if (ex.getMessage().contains("Table")) {
            // 处理表不存在异常
            // Table 'user' doesn't exist
            String[] split = ex.getMessage().split(" ");
            String msg = "表" + split[1] + ",不存在";
            return R.error(RCodeEnum.ERROR.getCode(), msg);
        } else if (ex.getMessage().contains("Unknown database")) {
            // 处理数据库不存在异常
            // Unknown database 'user'
            String[] split = ex.getMessage().split(" ");
            String msg = "数据库" + split[2] + ",不存在";
            return R.error(RCodeEnum.ERROR.getCode(), msg);
        } else {
            return R.error(RCodeEnum.ERROR.getCode(), "未知错误" + ex.getMessage());
        }
    }
}
   ```

# 用户服务的搭建

## 1. 依赖项

   ```
   <!--common-package-->
   <dependency>
      <groupId>com.ocean</groupId>
      <artifactId>common-package</artifactId>
      <version>1.0-SNAPSHOT</version>
   </dependency>
   <!--nacos依赖-->
   <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
   </dependency>
   <!--nacos配置依赖-->
   <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
   </dependency>
   <!--mybatis-plus统一管理包，包含了web依赖-->
   <dependency>
      <groupId>com.ocean</groupId>
      <artifactId>mybatis-plus-package</artifactId>
      <version>1.0-SNAPSHOT</version>
   </dependency>
   <!--redis依赖-->
   <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-redis</artifactId>
   </dependency>
   ```

## 2. yaml配置文件

    - 说明
      > 1. bootstrap.yml中的配置文件会先于application.yml加载
      > 2. bootstrap.yml主要配置端口号，nacos中心，以及读取nacos配置中心
      > 3. 注意，当你需要nacos配置时，记得引入依赖！
      > 4. application.yml主要配置数据库，redis等等
    - bootstrap.yml
      ```yaml
      server:
        port: 8001
      spring:
        application:
          ## 指定服务名称，在nacos中的名字
          name: service-user-8001
        cloud:
          nacos:
            discovery:
              # nacos的服务地址，nacos-server中IP地址:端口号
              server-addr: *:8848
            config:
              # nacos的服务地址，nacos-server中IP地址:端口号
              server-addr: *:8848
              # nacos中的配置文件名
              file-extension: yaml
              # group
              group: neu-website
              # nacos中的配置文件名,如果不写，则默认spring.application.name
              prefix: neu-website-config
      management:
        endpoints:
          web:
            exposure:
              ## yml文件中存在特殊字符，必须用单引号包含，否则启动报错
              include: '*'
      ```
    - application.yaml
       ```yaml
       spring:
        data:
          redis:
            host: ${redis.host}
            port: ${redis.port}
            password: ${redis.password}
            timeout: 10000
            database: 0
            jedis:
              pool:
                max-active: 8
                max-wait: -1
                max-idle: 8
                min-idle: 0
        datasource:
          type: ${mysql.type}
          driver-class-name: ${mysql.driver-class-name}
          url: ${mysql.url}
          username: ${mysql.username}
          password: ${mysql.password}
       mybatis-plus:
        configuration:
          map-underscore-to-camel-case: true
          log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
        global-config:
          db-config:
            id-type: ASSIGN_ID
       ```

## 3. mybatis-plus的使用看技术文档

## 4. 剩下的服务看具体代码中的注释

# 邮件服务

> 邮件服务隶属于mq-producer服务中，因为需要用到mq中的死信队列设置验证码的有效期

## 1. 依赖项

   ```
   <!--rabbitmq依赖-->
   <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-amqp</artifactId>
   </dependency>
   <!--web依赖-->
   <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
   </dependency>
   <!--邮件插件-->
   <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-mail</artifactId>
   </dependency>
   <!--redis依赖-->
   <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-redis</artifactId>
   </dependency>
   <!--common-package依赖-->
   <dependency>
      <groupId>com.ocean</groupId>
      <artifactId>common-package</artifactId>
      <version>1.0-SNAPSHOT</version>
   </dependency>
   <!--nacos配置依赖-->
   <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
   </dependency>
   <!--nacos依赖-->
   <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
   </dependency>
   ```

## 2. yaml配置

1. bootstrap配置与用户服务类似
2. application配置添加email和rabbitmq配置,去除数据库配置
    ```yaml
    spring:
     data:
       redis:
         host: ${redis.host}
         port: ${redis.port}
         password: ${redis.password}
         timeout: 10000
         database: 0
         jedis:
           pool:
             max-active: 8
             max-wait: -1
             max-idle: 8
             min-idle: 0
     rabbitmq:
       host: ${rabbitmq.host}
       port: ${rabbitmq.port}
       username: ${rabbitmq.username}
       password: ${rabbitmq.password}
       virtual-host: ${rabbitmq.virtual-host}
    email:
     host: ${email.host}
     protocol: ${email.protocol}
     username: ${email.username}
     password: ${email.password}
     port: ${email.port}
     default-encoding: ${email.default-encoding}
     from: ${email.from}
    ```

## 3. 创建email实体类，用来自动读取配置文件的中的信息

> 注意：@Component和@ConfigurationProperties(prefix = "email")必须同时使用，这样spring才会帮我们自动装填

   ```java
   package com.ocean.entity;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 * 读取配置文件中的email参数
 */
@Component
@Data
@ConfigurationProperties(prefix = "email")
public class EmailParam {
    // JavaMailSenderImpl的参数
    private String host; //设置发送方的邮箱格式
    private String protocol; //设置协议
    private String username; //设置发送方的邮箱
    private String password; //设置发送方的邮箱的授权码
    private int port; //设置端口号
    private String defaultEncoding; //设置默认编码格式

    // SimpleMailMessage的参数
    private String from; //设置发送方的邮箱，必须与username相同
}
   ```

## 4. 封装sendEmail工具

> EmailParam emailParam是我们自己封装的实体类，用来自动读取配置文件中的email参数。因为上面两个注解的存在，当我们在controller使用依赖注入时，这个参数会自动读取配置信息，封装成实体类传参

   ```java
   package com.ocean.util;

import com.ocean.entity.EmailParam;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSenderImpl;
import org.springframework.stereotype.Component;

import java.util.Properties;

@Component
public class SendEmail {
    private static JavaMailSenderImpl javaMailSender;
    private static SimpleMailMessage message;

    public SendEmail(EmailParam emailParam) {
        // 初始化JavaMailSenderImpl
        javaMailSender = new JavaMailSenderImpl();
        javaMailSender.setHost(emailParam.getHost());
        javaMailSender.setPort(emailParam.getPort());
        javaMailSender.setUsername(emailParam.getUsername());
        javaMailSender.setPassword(emailParam.getPassword());
        javaMailSender.setProtocol(emailParam.getProtocol());
        javaMailSender.setDefaultEncoding(emailParam.getDefaultEncoding());

        // 初始化SimpleMailMessage
        message = new SimpleMailMessage();
        message.setFrom(emailParam.getFrom());

        // 初始化配置
        Properties properties = new Properties();
        properties.setProperty("mail.smtp.auth", "true");
        properties.setProperty("mail.smtp.timeout", "25000");
        javaMailSender.setJavaMailProperties(properties);
    }

    public void sendEmail(String targetEmail, String title, String content) {
        message.setTo(targetEmail);
        message.setSubject(title);
        message.setText(content);
        // 发送邮件
        javaMailSender.send(message);
    }
}
   ```

## 5. 使用实例

> 关于mq的部分会在后面的mq服务中详细介绍

   ```
   package com.ocean.controller;
   
   import com.ocean.commonPackage.common.R;
   import com.ocean.commonPackage.common.RCode.RCodeEnum;
   import com.ocean.util.SendEmail;
   import com.ocean.util.Util;
   import org.springframework.amqp.rabbit.core.RabbitTemplate;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.data.redis.core.StringRedisTemplate;
   import org.springframework.web.bind.annotation.*;
   
   @RestController
   @RequestMapping("/mqProducer/temporaryInformation")
   public class TemporaryInformationController {
       private final RabbitTemplate rabbitTemplate;
       private final StringRedisTemplate stringRedisTemplate;
       private final SendEmail sendEmail;
   
       @Autowired
       private TemporaryInformationController(RabbitTemplate rabbitTemplate, StringRedisTemplate stringRedisTemplate, SendEmail sendEmail) {
           this.rabbitTemplate = rabbitTemplate;
           this.stringRedisTemplate = stringRedisTemplate;
           this.sendEmail = sendEmail;
       }
   
       @GetMapping("/emailVerificationCode/{email}")
       public R<String> emailVerificationCode(@PathVariable("email") String email) {
           String code = Util.getVerificationCode();
           try {
               sendEmail.sendEmail(email, "neu-website验证码", "您的验证码为：" + code);
               // 将code存入redis
               stringRedisTemplate.opsForHash().put("emailVerificationCode", email, code);
               // 发送消息到ttl，设置过期时间为10分钟，五分钟后删除redis中的验证码
               rabbitTemplate.convertAndSend("ttl_exchange", "temporaryInformationTTL", email);
               return R.success(RCodeEnum.SUCCESS.getCode(), "发送邮件成功", "验证码已发送至您的邮箱");
           }catch (Exception e){
               return R.error(RCodeEnum.ERROR.getCode(), "发送邮件失败");
           }
       }
   }
   ```

# MQ队列使用

## 1. 依赖

   ```
   <!--rabbitmq依赖-->
   <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-amqp</artifactId>
   </dependency>
   ```

## 2. 配置

   ```
   spring:
     rabbitmq:
       host: ${rabbitmq.host}
       port: ${rabbitmq.port}
       username: ${rabbitmq.username}
       password: ${rabbitmq.password}
       virtual-host: ${rabbitmq.virtual-host}
   ```

## 3. 初始化队列

> 本实例，给队列设置了消息过期时间，过期后会自动转发到死信队列，同时绑定了死信队列的交换机以及路由
>
> web启动类需要添加@EnableRabbit注解！

   ```java
   package com.ocean.queue;

import org.springframework.amqp.core.*;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;

// 延迟队列配置
// 本队列不设置监听器，只是用来存储消息，消息过期后，会自动转发到死信队列
@Configuration
public class TemporaryInformationTTLMqConfig {
    public static final String TTL_EXCHANGE_NAME = "ttl_exchange";
    public static final String TTL_QUEUE_NAME = "ttl_queue";

    // 1. 交换机
    @Bean
    public Exchange ttlExchange() {
        // 声明交换机名字，是否持久化
        return ExchangeBuilder.directExchange(TTL_EXCHANGE_NAME).durable(true).build();
    }

    // 2. Queue队列
    @Bean
    public Queue ttlQueue() {
        HashMap<String, Object> args = new HashMap<>();
        // 设置队列中的消息10min过期
        args.put("x-message-ttl", 600000);
        // 设置绑定交换机
        args.put("x-dead-letter-exchange", TemporaryInformationDeadMqConfig.DEAD_EXCHANGE_NAME);
        // 设置绑定交换机的routingKey
        args.put("x-dead-letter-routing-key", "temporaryInformationDead");
        return QueueBuilder.durable(TTL_QUEUE_NAME).withArguments(args).build();
    }

    // 3. Binding---交换机和队列的绑定关系
    @Bean
    public Binding ttlBinding() {
        return BindingBuilder.bind(ttlQueue()).to(ttlExchange()).with("temporaryInformationTTL").noargs();
    }
}
   ```

## 4. 私信队列

> 标准的direct队列创建，注意，这里的交换机和路由key要和上面的队列绑定的交换机和路由key一致

   ```java
   package com.ocean.queue;

import org.springframework.amqp.core.*;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

// 死信队列配置
@Configuration
public class TemporaryInformationDeadMqConfig {
    public static final String DEAD_EXCHANGE_NAME = "dead_exchange";
    public static final String DEAD_QUEUE_NAME = "dead_queue";

    @Bean
    public Exchange deadExchange() {
        return ExchangeBuilder.directExchange(DEAD_EXCHANGE_NAME).durable(true).build();
    }

    @Bean
    public Queue deadQueue() {
        return QueueBuilder.durable(DEAD_QUEUE_NAME).build();
    }

    @Bean
    public Binding deadBinding() {
        return BindingBuilder.bind(deadQueue()).to(deadExchange()).with("temporaryInformationDead").noargs();
    }
}
   ```

## 5. 使用队列推送消息

   ```
   // exchange, route, message
   rabbitTemplate.convertAndSend("ttl_exchange", "temporaryInformationTTL", email);
   ```

## 6. 接收消息

> 推荐单独一个新模块用来作为消息的消费者，依赖以及配置不变

   ```java
   package com.ocean.listener;

import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;

@Component
public class Listener {
    private final StringRedisTemplate stringRedisTemplate;

    @Autowired
    private Listener(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    @RabbitListener(queues = "dead_queue")
    public void listenDeadQueue(Message message) {
        String email = new String(message.getBody());
        System.out.println("收到过期消息，删除该邮箱的验证码：" + email);
        stringRedisTemplate.opsForHash().delete("emailVerificationCode", email);
    }
}
   ```

# websocket

## 1. 依赖项

```
<!--websocket依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
<!--json依赖-->
<dependency>
    <groupId>com.alibaba.fastjson2</groupId>
    <artifactId>fastjson2</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.12.0</version>
</dependency>
<dependency>
    <groupId>com.ocean</groupId>
    <artifactId>common-package</artifactId>
    <version>1.0-SNAPSHOT</version>
</dependency>
<!--nacos依赖-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```

## websocketConfig

```java
package com.ocean.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.server.standard.ServerEndpointExporter;

@Configuration
public class WebSocketConfig {
    /**
     * 如果使用Springboot默认内置的tomcat容器，则必须注入ServerEndpoint的bean；
     * 如果使用外置的web容器，则不需要提供ServerEndpointExporter，下面的注入可以注解掉
     */
    @Bean
    public ServerEndpointExporter serverEndpointExporter() {
        return new ServerEndpointExporter();
    }
}
```

## websocketServer

```java
package com.ocean.server;

import com.alibaba.fastjson2.JSON;
import com.ocean.commonPackage.entity.chatRoom.Message;
import jakarta.websocket.*;
import jakarta.websocket.server.PathParam;
import jakarta.websocket.server.ServerEndpoint;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.concurrent.ConcurrentHashMap;

@Component
@ServerEndpoint(value = "/ws/{code}")
public class WebSocketServer {
    private final static Logger log = LoggerFactory.getLogger(WebSocketServer.class);
    //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。
    private static int onlineCount = 0;
    //与某个客户端的连接会话，需要通过它来给客户端发送数据
    private Session session;
    //新：使用map对象优化，便于根据code来获取对应的WebSocket
    private static ConcurrentHashMap<String, WebSocketServer> websocketMap = new ConcurrentHashMap<>();
    //接收用户的code，指定需要推送的用户
    private String code;

    /**
     * 连接成功后调用的方法
     */
    @OnOpen
    public void onOpen(Session session, @PathParam("code") String code) {
        this.session = session;
        // 如果map中已经存在该code，则先删除，再加入
        if (websocketMap.get(code) != null) {
            websocketMap.remove(code);  //从map中删除
            subOnlineCount();           //在线数减1
        }
        websocketMap.put(code, this); //加入map中
        addOnlineCount();            //在线数加1
        log.info("有新用户登录:" + code + ",当前在线人数为" + getOnlineCount());
        this.code = code;
        //sendMessage("连接成功");
    }

    /**
     * 连接关闭调用的方法
     */
    @OnClose
    public void onClose() {
        if (websocketMap.get(this.code) != null) {
            websocketMap.remove(this.code);  //从map中删除
            subOnlineCount();           //在线数减1
            log.info("有一连接关闭！当前在线人数为" + getOnlineCount());
        }
    }

    /**
     * 收到客户端消息后调用的方法。
     * 收到消息后先村日redis中，再转发给目标客户端。
     *
     * @param message 客户端发送过来的消息
     */
    @OnMessage
    public void onMessage(String message, Session session) {
        log.info("收到来自窗口" + code + "的信息:" + message);
        //saveToRedis(msg, code);
        if (StringUtils.isNotBlank(message)) {
            Message msg = JSON.parseObject(message, Message.class);
            WebSocketServer server = websocketMap.get(msg.getReceiver());
            if (server != null) {
                try {
                    server.sendMessage(message);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            } else {
                // 如果用户不在线，则以系统账号发送消息给前端
                // 通知用户账户正在联系的好友不在线
                Message sysMsg = new Message("00000000", msg.getSender(), "好友不在线", null, 0);
                // 找到这个用户的websocket，发送消息
                WebSocketServer sysServer = websocketMap.get(msg.getSender());
                if (sysServer != null) {
                    try {
                        sysServer.sendMessage(JSON.toJSONString(sysMsg));
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    /**
     * 发生错误时的回调函数
     */
    @OnError
    public void onError(Session session, Throwable error) {
        log.error("发生错误");
        error.printStackTrace();
    }


    /**
     * 实现服务器主动推送消息
     */
    public void sendMessage(String message) throws IOException {
        this.session.getBasicRemote().sendText(message);
    }

    // 为了保证线程安全
    public static synchronized int getOnlineCount() {
        return onlineCount;
    }

    public static synchronized void addOnlineCount() {
        WebSocketServer.onlineCount++;
    }

    public static synchronized void subOnlineCount() {
        WebSocketServer.onlineCount--;
    }
}
```

# 附件

## nacos配置文件

> name：neu-website-config
> group：neu-website
> 类型：yaml

```yaml
redis:
  host: 111***
  port: 6379
  password: *
mysql:
  type: com.zaxxer.hikari.HikariDataSource
  driver-class-name: com.mysql.cj.jdbc.Driver
  url: jdbc:mysql://***:24377/neu_website?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowPublicKeyRetrieval=true
  username: *
  password: *
rabbitmq:
  host: *
  port: *
  username: *
  password: *
  virtual-host: *
email:
  host: smtp.qq.com
  protocol: smtp
  username: *
  password: *
  port: 587
  default-encoding: UTF-8
  from: *
```