# 项目搭建

## 父项目的搭建

1. 注意事项
   > - 推荐：父项目控制子项目的依赖版本
   >- 推荐：尤其是spring-boot和spring-cloud的版本以及spring-cloud-alibaba的版本
   >- 注意：jdk的版本，spring-boot3.0以上需要jdk11
   >- 注意：其他的依赖不代表最终版本，后续功能的需要请自行添加
2. maven配置
    ```
    <?xml version="1.0" encoding="UTF-8"?>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>
    
        <groupId>com.ocean</groupId>
        <artifactId>backend</artifactId>
        <version>1.0-SNAPSHOT</version>
    
        <!--依赖版本的统一管理-->
        <properties>
            <maven.compiler.source>18</maven.compiler.source>
            <maven.compiler.target>18</maven.compiler.target>
            <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
            <!--版本管理-->
            <spring-cloud.version>2022.0.0</spring-cloud.version>
            <spring-boot.version>3.0.2</spring-boot.version>
            <spring-cloud-alibaba.version>2022.0.0.0-RC2</spring-cloud-alibaba.version>
            <mybatis-plus.version>3.5.3.1</mybatis-plus.version>
            <mysql-connector-j.version>8.0.33</mysql-connector-j.version>
            <druid.version>1.2.18</druid.version>
            <fastjson2.version>2.0.38</fastjson2.version>
        </properties>
    
        <!--默认依赖导入-->
        <dependencyManagement>
            <dependencies>
                <!--spring-cloud依赖-->
                <dependency>
                    <groupId>org.springframework.cloud</groupId>
                    <artifactId>spring-cloud-dependencies</artifactId>
                    <version>${spring-cloud.version}</version>
                    <type>pom</type>
                    <scope>import</scope>
                </dependency>
                <!--spring-boot一依赖-->
                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-dependencies</artifactId>
                    <version>${spring-boot.version}</version>
                    <type>pom</type>
                    <scope>import</scope>
                </dependency>
                <!--spring-cloud-alibaba-->
                <dependency>
                    <groupId>com.alibaba.cloud</groupId>
                    <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                    <version>${spring-cloud-alibaba.version}</version>
                    <type>pom</type>
                    <scope>import</scope>
                </dependency>
                <!--mybatis-plus依赖-->
                <dependency>
                    <groupId>com.baomidou</groupId>
                    <artifactId>mybatis-plus-boot-starter</artifactId>
                    <version>${mybatis-plus.version}</version>
                </dependency>
                <!--mysql-connector-j依赖-->
                <dependency>
                    <groupId>com.mysql</groupId>
                    <artifactId>mysql-connector-j</artifactId>
                    <version>${mysql-connector-j.version}</version>
                </dependency>
                <!--druid依赖-->
                <dependency>
                    <groupId>com.alibaba</groupId>
                    <artifactId>druid</artifactId>
                    <version>${druid.version}</version>
                </dependency>
                <!--fastjson2依赖-->
                <dependency>
                    <groupId>com.alibaba.fastjson2</groupId>
                    <artifactId>fastjson2</artifactId>
                    <version>${fastjson2.version}</version>
                </dependency>
            </dependencies>
        </dependencyManagement>
    
        <!--公共依赖管理-->
        <dependencies>
            <!--lombok依赖-->
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
            </dependency>
            <!--bootstrap依赖-->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-starter-bootstrap</artifactId>
            </dependency>
        </dependencies>
    </project>
    ```

## common-package

1. maven配置
   > 不用导入任何依赖，需要的lombok依赖在父项目中已经导入
2. 前后端公共返回类
   ```java
   package com.ocean.comomPackage.common;
   
   import lombok.Data;
   
   /**
    * 通用返回结果类
    *
    * @param <T>
    */
   @Data
   public class R<T> {
   
       private Integer code; //编码：1成功，0和其它数字为失败
   
       private String msg; //错误信息
   
       private T data; //数据
   
       public static <T> R<T> success(Integer code, String msg, T object) {
           R<T> r = new R<T>();
           r.data = object;
           r.code = code;
           r.msg = msg;
           return r;
       }
   
       public static <T> R<T> error(Integer code, String msg) {
           R r = new R();
           r.msg = msg;
           r.code = 0;
           return r;
       }
   }
   ```
3. RCodeEnum
   > 用来规范返回的code（后续可以添加更多枚举）
   ```java
   package com.ocean.commonPackage.common.RCode;
   
   public enum RCodeEnum {
       SUCCESS(200, "成功"), // 成功
       PARAM_ERROR(400, "参数错误"), // 参数错误
       NO_DATA(404, "没找到数据"), // 没找到数据
       IS_DELETED(405, "数据已被删除"), // 数据已被删除
       ERROR(500, "错误"), // 错误
       IDENTIFY_ERROR(501, "身份验证失败"), // 身份验证失败
       ;
   
       private Integer code;
       private String msg;
   
       RCodeEnum(Integer code, String msg) {
           this.code = code;
           this.msg = msg;
       }
   
       public Integer getCode() {
           return this.code;
       }
   
       public String getMsg() {
           return this.msg;
       }
   }
   ```
4. 主要功能
   > 用于保存公共实体类，例如：用户实体类，前后端传递参数的实体类等等

## mybatis-plus-package

> 主要用于保存对应表的实体类，以及异常处理、全局配置、自动注入等等

1. 依赖项
   ```
   <!--mybatis-plus依赖-->
   <dependency>
      <groupId>com.baomidou</groupId>
      <artifactId>mybatis-plus-boot-starter</artifactId>
   </dependency>
   <!--mysql依赖-->
   <dependency>
      <groupId>com.mysql</groupId>
      <artifactId>mysql-connector-j</artifactId>
   </dependency>
   <!--druid依赖-->
   <dependency>
      <groupId>com.alibaba</groupId>
      <artifactId>druid</artifactId>
   </dependency>
   <!--web依赖，主要用于处理全局异常的annotation-->
   <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
   </dependency>
   <!--common-package-->
   <dependency>
      <groupId>com.ocean</groupId>
      <artifactId>common-package</artifactId>
      <version>1.0-SNAPSHOT</version>
   </dependency>
   ```
2. 实体类举例
   ```java
   package com.ocean.mpPackage.sqlEntity;
   
   import com.baomidou.mybatisplus.annotation.FieldFill;
   import com.baomidou.mybatisplus.annotation.TableField;
   import com.baomidou.mybatisplus.annotation.TableName;
   import lombok.AllArgsConstructor;
   import lombok.Data;
   import lombok.NoArgsConstructor;
   
   import java.math.BigInteger;
   import java.sql.Timestamp;
   
   @Data
   @AllArgsConstructor
   @NoArgsConstructor
   @TableName("user")
   public class User {
       private BigInteger id;  // 数据库随机uuid
       private String code;    // 学号，规定为8位
       private String password; // 密码
       private String nickname; // 昵称
       private String campus; // 校区
       private String dormitory; // 宿舍
       private Integer isDeleted; // 数据库插入时会默认为0，删除时会改为1
       private String email; // 邮箱
       private String phone; // 手机号
       @TableField(fill = FieldFill.INSERT)
       private Timestamp gmtCreate; // 数据库插入时会自动填充
       @TableField(fill = FieldFill.INSERT_UPDATE)
       private Timestamp gmtModified; // 数据库插入和更新时会自动填充
       @TableField(exist = false)
       private String token; // 排除字段，不与数据库进行匹配，只是用来判断登录的权限
   }
   ```
3. 自动填充配置（时间）
   ```java
   package com.ocean.mpPackage.handler;
   
   import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
   import org.apache.ibatis.reflection.MetaObject;
   import org.springframework.stereotype.Component;
   
   import java.sql.Timestamp;
   import java.time.LocalDateTime;
   
   @Component
   public class MyMetaObjectHandler implements MetaObjectHandler {
       @Override
       public void insertFill(MetaObject metaObject) {
           metaObject.setValue("gmtCreate", Timestamp.valueOf(LocalDateTime.now()));
           metaObject.setValue("gmtModified", Timestamp.valueOf(LocalDateTime.now()));
       }
   
       @Override
       public void updateFill(MetaObject metaObject) {
           // 注意，如果要这里生效，需要这样使用update：update(new User(), updateWrapper);
           // 如果update(updateWrapper);使用，更改不会生效！！！
           // 下面三种方式均可以触发更新
           // boolean saveOrUpdate(T entity)
           // boolean saveOrUpdate(T entity, Wrapper<T> updateWrapper)
           // update(T entity, Wrapper<T> updateWrapper)
           metaObject.setValue("gmtModified", Timestamp.valueOf(LocalDateTime.now()));
       }
   }
   ```
4. 处理异常
   ```java
   package com.ocean.mpPackage.globalException;
   
   import com.ocean.commonPackage.common.R;
   import com.ocean.commonPackage.common.RCode.RCodeEnum;
   import org.springframework.web.bind.annotation.ControllerAdvice;
   import org.springframework.web.bind.annotation.ExceptionHandler;
   import org.springframework.web.bind.annotation.ResponseBody;
   
   import java.sql.SQLIntegrityConstraintViolationException;
   import java.sql.SQLSyntaxErrorException;
   
   @ControllerAdvice
   @ResponseBody
   public class SqlExceptionHandler {
       // 处理重复异常
       @ExceptionHandler(value = SQLIntegrityConstraintViolationException.class)
       public R<String> exceptionHandler(SQLIntegrityConstraintViolationException ex) {
           // 处理重复异常
           // Duplicate entry 'ocean' for key 'idx_username'
           if (ex.getMessage().contains("Duplicate entry")) {
               String[] split = ex.getMessage().split(" ");
               String msg = split[2] + "已存在";
               return R.error(RCodeEnum.ERROR.getCode(), msg);
           }
           return R.error(RCodeEnum.ERROR.getCode(), "未知错误：" + ex.getMessage());
       }
   
       // 处理列、表、数据库不存在异常
       @ExceptionHandler(value = SQLSyntaxErrorException.class)
       public R<String> exceptionHandler(SQLSyntaxErrorException ex) {
           // 处理列名不存在异常
           // Unknown column 'username' in 'field list'
           if (ex.getMessage().contains("Unknown column")) {
               String[] split = ex.getMessage().split(" ");
               String msg = "列：" + split[2] + ",不存在";
               return R.error(RCodeEnum.ERROR.getCode(), msg);
           } else if (ex.getMessage().contains("Table")) {
               // 处理表不存在异常
               // Table 'user' doesn't exist
               String[] split = ex.getMessage().split(" ");
               String msg = "表" + split[1] + ",不存在";
               return R.error(RCodeEnum.ERROR.getCode(), msg);
           } else if (ex.getMessage().contains("Unknown database")) {
               // 处理数据库不存在异常
               // Unknown database 'user'
               String[] split = ex.getMessage().split(" ");
               String msg = "数据库" + split[2] + ",不存在";
               return R.error(RCodeEnum.ERROR.getCode(), msg);
           } else {
               return R.error(RCodeEnum.ERROR.getCode(), "未知错误" + ex.getMessage());
           }
       }
   }
   ```

# 用户服务的搭建

1. 依赖项
   ```
   <!--common-package-->
   <dependency>
      <groupId>com.ocean</groupId>
      <artifactId>common-package</artifactId>
      <version>1.0-SNAPSHOT</version>
   </dependency>
   <!--nacos依赖-->
   <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
   </dependency>
   <!--nacos配置依赖-->
   <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
   </dependency>
   <!--mybatis-plus统一管理包，包含了web依赖-->
   <dependency>
      <groupId>com.ocean</groupId>
      <artifactId>mybatis-plus-package</artifactId>
      <version>1.0-SNAPSHOT</version>
   </dependency>
   <!--redis依赖-->
   <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-redis</artifactId>
   </dependency>
   ```
2. yaml配置文件
    - 说明
      > 1. bootstrap.yml中的配置文件会先于application.yml加载
      > 2. bootstrap.yml主要配置端口号，nacos中心，以及读取nacos配置中心
      > 3. 注意，当你需要nacos配置时，记得引入依赖！
      > 4. application.yml主要配置数据库，redis等等
    - bootstrap.yml
      ```yaml
      server:
        port: 8001
      spring:
        application:
          ## 指定服务名称，在nacos中的名字
          name: service-user-8001
        cloud:
          nacos:
            discovery:
              # nacos的服务地址，nacos-server中IP地址:端口号
              server-addr: *:8848
            config:
              # nacos的服务地址，nacos-server中IP地址:端口号
              server-addr: *:8848
              # nacos中的配置文件名
              file-extension: yaml
              # group
              group: neu-website
              # nacos中的配置文件名,如果不写，则默认spring.application.name
              prefix: neu-website-config
      management:
        endpoints:
          web:
            exposure:
              ## yml文件中存在特殊字符，必须用单引号包含，否则启动报错
              include: '*'
      ```
    - application.yaml
       ```yaml
       spring:
        data:
          redis:
            host: ${redis.host}
            port: ${redis.port}
            password: ${redis.password}
            timeout: 10000
            database: 0
            jedis:
              pool:
                max-active: 8
                max-wait: -1
                max-idle: 8
                min-idle: 0
        datasource:
          type: ${mysql.type}
          driver-class-name: ${mysql.driver-class-name}
          url: ${mysql.url}
          username: ${mysql.username}
          password: ${mysql.password}
       mybatis-plus:
        configuration:
          map-underscore-to-camel-case: true
          log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
        global-config:
          db-config:
            id-type: ASSIGN_ID
       ```
3. mybatis-plus的使用看技术文档
4. 剩下的服务看具体代码中的注释

# 邮件服务

> 邮件服务隶属于mq-producer服务中，因为需要用到mq中的死信队列设置验证码的有效期

1. 依赖项
   ```
   <!--rabbitmq依赖-->
   <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-amqp</artifactId>
   </dependency>
   <!--web依赖-->
   <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
   </dependency>
   <!--邮件插件-->
   <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-mail</artifactId>
   </dependency>
   <!--redis依赖-->
   <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-redis</artifactId>
   </dependency>
   <!--common-package依赖-->
   <dependency>
      <groupId>com.ocean</groupId>
      <artifactId>common-package</artifactId>
      <version>1.0-SNAPSHOT</version>
   </dependency>
   <!--nacos配置依赖-->
   <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
   </dependency>
   <!--nacos依赖-->
   <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
   </dependency>
   ```
2. yaml配置
    - bootstrap配置与用户服务类似
    - application配置添加email和rabbitmq配置,去除数据库配置
       ```yaml
       spring:
         data:
           redis:
             host: ${redis.host}
             port: ${redis.port}
             password: ${redis.password}
             timeout: 10000
             database: 0
             jedis:
               pool:
                 max-active: 8
                 max-wait: -1
                 max-idle: 8
                 min-idle: 0
         rabbitmq:
           host: ${rabbitmq.host}
           port: ${rabbitmq.port}
           username: ${rabbitmq.username}
           password: ${rabbitmq.password}
           virtual-host: ${rabbitmq.virtual-host}
       email:
         host: ${email.host}
         protocol: ${email.protocol}
         username: ${email.username}
         password: ${email.password}
         port: ${email.port}
         default-encoding: ${email.default-encoding}
         from: ${email.from}
       ```
3. 创建email实体类，用来自动读取配置文件的中的信息
   > 注意：@Component和@ConfigurationProperties(prefix = "email")必须同时使用，这样spring才会帮我们自动装填
   ```java
   package com.ocean.entity;
   
   import lombok.Data;
   import org.springframework.boot.context.properties.ConfigurationProperties;
   import org.springframework.stereotype.Component;
   
   /**
    * 读取配置文件中的email参数
    */
   @Component
   @Data
   @ConfigurationProperties(prefix = "email")
   public class EmailParam {
       // JavaMailSenderImpl的参数
       private String host; //设置发送方的邮箱格式
       private String protocol; //设置协议
       private String username; //设置发送方的邮箱
       private String password; //设置发送方的邮箱的授权码
       private int port; //设置端口号
       private String defaultEncoding; //设置默认编码格式
   
       // SimpleMailMessage的参数
       private String from; //设置发送方的邮箱，必须与username相同
   }
   ```
4. 封装sendEmail工具
   > EmailParam emailParam是我们自己封装的实体类，用来自动读取配置文件中的email参数。因为上面两个注解的存在，当我们在controller使用依赖注入时，这个参数会自动读取配置信息，封装成实体类传参
   ```java
   package com.ocean.util;
   
   import com.ocean.entity.EmailParam;
   import org.springframework.mail.SimpleMailMessage;
   import org.springframework.mail.javamail.JavaMailSenderImpl;
   import org.springframework.stereotype.Component;
   
   import java.util.Properties;
   
   @Component
   public class SendEmail {
       private static JavaMailSenderImpl javaMailSender;
       private static SimpleMailMessage message;
   
       public SendEmail(EmailParam emailParam) {
           // 初始化JavaMailSenderImpl
           javaMailSender = new JavaMailSenderImpl();
           javaMailSender.setHost(emailParam.getHost());
           javaMailSender.setPort(emailParam.getPort());
           javaMailSender.setUsername(emailParam.getUsername());
           javaMailSender.setPassword(emailParam.getPassword());
           javaMailSender.setProtocol(emailParam.getProtocol());
           javaMailSender.setDefaultEncoding(emailParam.getDefaultEncoding());
   
           // 初始化SimpleMailMessage
           message = new SimpleMailMessage();
           message.setFrom(emailParam.getFrom());
   
           // 初始化配置
           Properties properties = new Properties();
           properties.setProperty("mail.smtp.auth", "true");
           properties.setProperty("mail.smtp.timeout", "25000");
           javaMailSender.setJavaMailProperties(properties);
       }
   
       public void sendEmail(String targetEmail, String title, String content) {
           message.setTo(targetEmail);
           message.setSubject(title);
           message.setText(content);
           // 发送邮件
           javaMailSender.send(message);
       }
   }
   ```
5. 使用实例
   > 关于mq的部分会在后面的mq服务中详细介绍
   ```
   package com.ocean.controller;
   
   import com.ocean.commonPackage.common.R;
   import com.ocean.commonPackage.common.RCode.RCodeEnum;
   import com.ocean.util.SendEmail;
   import com.ocean.util.Util;
   import org.springframework.amqp.rabbit.core.RabbitTemplate;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.data.redis.core.StringRedisTemplate;
   import org.springframework.web.bind.annotation.*;
   
   @RestController
   @RequestMapping("/mqProducer/temporaryInformation")
   public class TemporaryInformationController {
       private final RabbitTemplate rabbitTemplate;
       private final StringRedisTemplate stringRedisTemplate;
       private final SendEmail sendEmail;
   
       @Autowired
       private TemporaryInformationController(RabbitTemplate rabbitTemplate, StringRedisTemplate stringRedisTemplate, SendEmail sendEmail) {
           this.rabbitTemplate = rabbitTemplate;
           this.stringRedisTemplate = stringRedisTemplate;
           this.sendEmail = sendEmail;
       }
   
       @GetMapping("/emailVerificationCode/{email}")
       public R<String> emailVerificationCode(@PathVariable("email") String email) {
           String code = Util.getVerificationCode();
           try {
               sendEmail.sendEmail(email, "neu-website验证码", "您的验证码为：" + code);
               // 将code存入redis
               stringRedisTemplate.opsForHash().put("emailVerificationCode", email, code);
               // 发送消息到ttl，设置过期时间为10分钟，五分钟后删除redis中的验证码
               rabbitTemplate.convertAndSend("ttl_exchange", "temporaryInformationTTL", email);
               return R.success(RCodeEnum.SUCCESS.getCode(), "发送邮件成功", "验证码已发送至您的邮箱");
           }catch (Exception e){
               return R.error(RCodeEnum.ERROR.getCode(), "发送邮件失败");
           }
       }
   }
   ```

# MQ队列使用

1. 依赖
   ```
   <!--rabbitmq依赖-->
   <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-amqp</artifactId>
   </dependency>
   ```
2. 配置
   ```
   spring:
     rabbitmq:
       host: ${rabbitmq.host}
       port: ${rabbitmq.port}
       username: ${rabbitmq.username}
       password: ${rabbitmq.password}
       virtual-host: ${rabbitmq.virtual-host}
   ```
3. 初始化队列
   > 本实例，给队列设置了消息过期时间，过期后会自动转发到死信队列，同时绑定了死信队列的交换机以及路由
   >
   > web启动类需要添加@EnableRabbit注解！
   ```java
   package com.ocean.queue;
   
   import org.springframework.amqp.core.*;
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   
   import java.util.HashMap;
   
   // 延迟队列配置
   // 本队列不设置监听器，只是用来存储消息，消息过期后，会自动转发到死信队列
   @Configuration
   public class TemporaryInformationTTLMqConfig {
       public static final String TTL_EXCHANGE_NAME = "ttl_exchange";
       public static final String TTL_QUEUE_NAME = "ttl_queue";
   
       // 1. 交换机
       @Bean
       public Exchange ttlExchange() {
           // 声明交换机名字，是否持久化
           return ExchangeBuilder.directExchange(TTL_EXCHANGE_NAME).durable(true).build();
       }
   
       // 2. Queue队列
       @Bean
       public Queue ttlQueue() {
           HashMap<String, Object> args = new HashMap<>();
           // 设置队列中的消息10min过期
           args.put("x-message-ttl", 600000);
           // 设置绑定交换机
           args.put("x-dead-letter-exchange", TemporaryInformationDeadMqConfig.DEAD_EXCHANGE_NAME);
           // 设置绑定交换机的routingKey
           args.put("x-dead-letter-routing-key", "temporaryInformationDead");
           return QueueBuilder.durable(TTL_QUEUE_NAME).withArguments(args).build();
       }
   
       // 3. Binding---交换机和队列的绑定关系
       @Bean
       public Binding ttlBinding() {
           return BindingBuilder.bind(ttlQueue()).to(ttlExchange()).with("temporaryInformationTTL").noargs();
       }
   }
   ```
4. 私信队列
   > 标准的direct队列创建，注意，这里的交换机和路由key要和上面的队列绑定的交换机和路由key一致
   ```java
   package com.ocean.queue;
   
   import org.springframework.amqp.core.*;
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   
   // 死信队列配置
   @Configuration
   public class TemporaryInformationDeadMqConfig {
       public static final String DEAD_EXCHANGE_NAME = "dead_exchange";
       public static final String DEAD_QUEUE_NAME = "dead_queue";
   
       @Bean
       public Exchange deadExchange() {
           return ExchangeBuilder.directExchange(DEAD_EXCHANGE_NAME).durable(true).build();
       }
   
       @Bean
       public Queue deadQueue() {
           return QueueBuilder.durable(DEAD_QUEUE_NAME).build();
       }
   
       @Bean
       public Binding deadBinding() {
           return BindingBuilder.bind(deadQueue()).to(deadExchange()).with("temporaryInformationDead").noargs();
       }
   }
   ```
5. 使用队列推送消息
   ```
   // exchange, route, message
   rabbitTemplate.convertAndSend("ttl_exchange", "temporaryInformationTTL", email);
   ```
6. 接收消息
   > 推荐单独一个新模块用来作为消息的消费者，依赖以及配置不变
   ```java
   package com.ocean.listener;
   
   import org.springframework.amqp.core.Message;
   import org.springframework.amqp.rabbit.annotation.RabbitListener;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.data.redis.core.StringRedisTemplate;
   import org.springframework.stereotype.Component;
   
   @Component
   public class Listener {
       private final StringRedisTemplate stringRedisTemplate;
   
       @Autowired
       private Listener(StringRedisTemplate stringRedisTemplate) {
           this.stringRedisTemplate = stringRedisTemplate;
       }
   
       @RabbitListener(queues = "dead_queue")
       public void listenDeadQueue(Message message) {
           String email = new String(message.getBody());
           System.out.println("收到过期消息，删除该邮箱的验证码：" + email);
           stringRedisTemplate.opsForHash().delete("emailVerificationCode", email);
       }
   }
   ```

# 附件

## nacos配置文件

> name：neu-website-config
> group：neu-website
> 类型：yaml

```yaml
redis:
  host: 111***
  port: 6379
  password: *
mysql:
  type: com.zaxxer.hikari.HikariDataSource
  driver-class-name: com.mysql.cj.jdbc.Driver
  url: jdbc:mysql://***:24377/neu_website?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowPublicKeyRetrieval=true
  username: *
  password: *
rabbitmq:
  host: *
  port: *
  username: *
  password: *
  virtual-host: *
email:
  host: smtp.qq.com
  protocol: smtp
  username: *
  password: *
  port: 587
  default-encoding: UTF-8
  from: *
```